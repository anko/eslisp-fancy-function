(= prelude (require "prelude-ls"))
(= break-list prelude.break-list)

(= is-splat (function (x) (return (== 0 (x.atom.indexOf "...")))))

(:= module.exports
    (function
      ()

      (= prepend-statements (array))

      (= args (Array.prototype.slice.call arguments 0))
      (= function-args args.0)
      (= function-body (args.slice 1))

      (= break-results (break-list is-splat function-args))

      (= before-splat break-results.0)

      (= splat-and-after break-results.1)

      (= n-splats (. (splat-and-after.filter is-splat) length))
      (if (> n-splats 1)
        ( (throw (Error "too many splats in function arguments (expected <=1)")) ))

      (= splat splat-and-after.0)

      (if splat
        (
         (= after-splat (splat-and-after.slice 1))
         (= splat-name (splat.atom.slice 3))
         (switch true

                 ; Splat is the only argument: just slice all
                 ((== (+ before-splat.length after-splat.length) 0)
                  (= splat-slice-call `(= ,(object atom splat-name)
                                          ((. Array prototype slice call)
                                           arguments)))
                  (prepend-statements.push splat-slice-call)
                  (break))

                 ; Splat is last argument: slice from there to end
                 ((== after-splat.length 0)
                  (= splat-slice-call `(= ,(object atom splat-name)
                                          ((. Array prototype slice call)
                                           arguments ,before-splat.length)))
                  (prepend-statements.push splat-slice-call)
                  (break))

                 ; Splat is in-between argument: calculate correct slice
                 ; offsets and assign after-splat args accordingly
                 (default
                   (= splat-start before-splat.length)
                   (= splat-end (- after-splat.length))
                   (= splat-slice-call
                      `(= ,(object atom splat-name)
                          ((. Array prototype slice call)
                           arguments ,splat-start ,splat-end)))

                   (prepend-statements.push splat-slice-call)

                   (after-splat.for-each
                     (function (x i)
                               (prepend-statements.push
                                 `(= ,x (. arguments
                                           (- arguments.length
                                              ,(- after-splat.length i)))))))
                   ))))

      ; If the last thing is an expression, add an implicit "return"
      (= last-thing-in-body (function-body.pop))
      (if last-thing-in-body ; Just in case the function body was empty
        (
          (= last-converted (?: (this.is-expr last-thing-in-body)
                                `(return ,last-thing-in-body)
                                last-thing-in-body))
          (function-body.push last-converted)))

      (return `(function ,before-splat ,@prepend-statements ,@function-body))))
